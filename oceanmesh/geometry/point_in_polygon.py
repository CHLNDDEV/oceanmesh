"""GPL-compatible 2D point-in-polygon implementation.

This module provides a drop-in replacement for the classic
``inpoly2(vert, node, edge=None, ftol=5.0e-14)`` function used in
:oceanmesh:. It implements a pure-Python ray-casting backend plus
optional fast paths using Shapely and Matplotlib when available, and
can optionally use a Cython-accelerated kernel when compiled.

The API matches the historical ``inpoly2`` signature from
``oceanmesh._vendor.inpoly.inpoly2``:

- ``vert``: (N, 2) array-like of query points.
- ``node``: (M, 2) array-like of polygon vertices.
- ``edge``: (P, 2) array-like of vertex indices defining edges, or None
  to connect vertices in ascending order.
- ``ftol``: floating-point tolerance used for boundary detection.

It returns ``(STAT, BNDS)``:

- ``STAT``: boolean array of length N, True where the point is inside
  the polygon (excluding the boundary).
- ``BNDS``: boolean array of length N, True where the point lies on the
  polygon boundary within the given tolerance.
"""

from __future__ import annotations

import logging
import os
from typing import Literal, Optional, Tuple

import numpy as np

try:  # optional fast path
    import shapely.geometry as _shapely_geom
    import shapely.prepared as _shapely_prep

    _HAVE_SHAPELY = True
except Exception:  # pragma: no cover - optional dependency
    _HAVE_SHAPELY = False

try:  # optional fast path
    from matplotlib.path import Path as _MplPath

    _HAVE_MPL = True
except Exception:  # pragma: no cover - optional dependency
    _HAVE_MPL = False


logger = logging.getLogger(__name__)


_COMPILED_KERNEL_AVAILABLE = False
_ACCEL_ENV = os.environ.get("OCEANMESH_INPOLY_ACCEL", "1")
if _ACCEL_ENV.lower() not in {"0", "false", "no", "off"}:
    try:  # pragma: no cover - exercised only when extension present
        from oceanmesh.geometry.point_in_polygon_ import inpoly2_fast  # type: ignore

        _COMPILED_KERNEL_AVAILABLE = True
    except Exception:  # pragma: no cover - extension missing or failed
        logger.warning(
            "Cython-accelerated inpoly2 kernel is not available; "
            "falling back to Python backends. Set OCEANMESH_INPOLY_ACCEL=0 "
            "to silence this warning if you intend to run without acceleration."
        )
        if os.environ.get("OCEANMESH_INPOLY_ACCEL_DEBUG"):
            import traceback

            traceback.print_exc()


MethodName = Literal["raycasting", "shapely", "matplotlib"]


def inpoly2(
    vert,
    node,
    edge=None,
    ftol: float = 5.0e-14,
):
    """Vectorised point-in-polygon test with optional fast paths.

    Parameters
    ----------
    vert : array_like, shape (N, 2)
        Query point coordinates.
    node : array_like, shape (M, 2)
        Polygon vertex coordinates.
    edge : array_like, shape (P, 2), optional
        Vertex indices defining the polygon edges. Edges are assumed to
        encode one or more closed, non-self-intersecting rings. If
        ``edge`` is None, a single closed ring is generated by
        connecting successive vertices and closing the polygon.
    ftol : float, optional
        Tolerance for boundary detection.

    Returns
    -------
    STAT : ndarray of bool, shape (N,)
           True where the point lies inside the polygon or on its
           boundary (see ``BNDS``).
    BNDS : ndarray of bool, shape (N,)
        True where the point lies on the polygon boundary (within ``ftol``).
    """

    vert_arr = _as_points_array(vert)
    node_arr = _as_points_array(node)

    n_vert = vert_arr.shape[0]
    if node_arr.size == 0:
        return np.zeros(n_vert, dtype=bool), np.zeros(n_vert, dtype=bool)

    # Generate edges if not supplied.
    if edge is None:
        m = node_arr.shape[0]
        if m < 2:
            return np.zeros(n_vert, dtype=bool), np.zeros(n_vert, dtype=bool)
        idx = np.arange(m, dtype=np.int32)
        edge_arr = np.column_stack([idx, np.roll(idx, -1).astype(np.int32)])
    else:
        edge_arr = np.asarray(edge, dtype=np.int32)
        if edge_arr.ndim != 2 or edge_arr.shape[1] != 2:
            raise ValueError("edge must have shape (P, 2)")

    # Basic validation: clip indices to valid range (defensive).
    m = node_arr.shape[0]
    if edge_arr.size:
        if edge_arr.min() < 0 or edge_arr.max() >= m:
            raise ValueError("edge indices out of bounds for node array")

    # Handle NaN query points by masking them out and restoring later.
    isnan = ~np.isfinite(vert_arr).all(axis=1)
    valid_mask = ~isnan
    if not valid_mask.any():
        return np.zeros(n_vert, dtype=bool), np.zeros(n_vert, dtype=bool)

    vert_valid = vert_arr[valid_mask]

    # If the user has explicitly requested a particular Python
    # backend, honour that and bypass the compiled kernel. This makes
    # OCEANMESH_INPOLY_METHOD the primary control knob, with
    # OCEANMESH_INPOLY_ACCEL acting as an opt-in for acceleration when
    # method selection is left automatic.
    method_env = os.environ.get("OCEANMESH_INPOLY_METHOD", "").strip().lower()
    if (
        method_env not in {"raycasting", "shapely", "matplotlib"}
        and _COMPILED_KERNEL_AVAILABLE
    ):
        try:
            inside, bnds = inpoly2_fast(vert_valid, node_arr, edge_arr, float(ftol))
            stat = np.zeros(n_vert, dtype=bool)
            bnd = np.zeros(n_vert, dtype=bool)
            stat[valid_mask] = inside
            bnd[valid_mask] = bnds
            return stat, bnd
        except Exception:  # pragma: no cover - debug only when requested
            logger.warning(
                "Cython-accelerated inpoly2 kernel raised an exception; "
                "falling back to Python backends. Set "
                "OCEANMESH_INPOLY_ACCEL_DEBUG=1 for details."
            )
            if os.environ.get("OCEANMESH_INPOLY_ACCEL_DEBUG"):
                import traceback

                traceback.print_exc()

    # Strategy selection
    method = _select_method(vert_valid.shape[0], edge_arr.shape[0])
    if method == "shapely" and _HAVE_SHAPELY:
        inside, bnds = _inpoly_shapely(vert_valid, node_arr, edge_arr, ftol)
    elif method == "matplotlib" and _HAVE_MPL:
        inside, bnds = _inpoly_matplotlib(vert_valid, node_arr, edge_arr, ftol)
    else:
        inside, bnds = _inpoly_raycasting(vert_valid, node_arr, edge_arr, ftol)

    stat = np.zeros(n_vert, dtype=bool)
    bnd = np.zeros(n_vert, dtype=bool)
    stat[valid_mask] = inside
    bnd[valid_mask] = bnds
    # NaN locations remain False/False.
    return stat, bnd


def _as_points_array(obj) -> np.ndarray:
    arr = np.asarray(obj, dtype=float)
    if arr.ndim != 2 or arr.shape[1] != 2:
        raise ValueError("expected array with shape (N, 2)")
    return arr


def _select_method(n_points: int, n_edges: int) -> MethodName:
    env = os.environ.get("OCEANMESH_INPOLY_METHOD", "").strip().lower()
    if env in {"raycasting", "shapely", "matplotlib"}:
        return env  # type: ignore[return-value]

    # Heuristic: small problems use raycasting to avoid overhead.
    if n_points < 1000 and n_edges < 1000:
        return "raycasting"

    # Larger problems: prefer shapely, then matplotlib, then raycasting.
    if _HAVE_SHAPELY:
        return "shapely"
    if _HAVE_MPL:
        return "matplotlib"
    return "raycasting"


# ---------------------------------------------------------------------------
# Pure-Python ray-casting backend
# ---------------------------------------------------------------------------


def _inpoly_raycasting(
    vert: np.ndarray,
    node: np.ndarray,
    edge: np.ndarray,
    ftol: float,
) -> Tuple[np.ndarray, np.ndarray]:
    """Ray-casting point-in-polygon with simple bounding-box pruning.

    This function implements a vectorised variant of the classic
    crossing-number algorithm. It is intended as a GPL-compatible
    reimplementation, not a line-by-line port, of the algorithmic
    structure used in the historical inpoly2 routine.
    """

    n = vert.shape[0]
    inside = np.zeros(n, dtype=bool)
    bnds = np.zeros(n, dtype=bool)

    if edge.size == 0 or node.shape[0] < 3 or n == 0:
        return inside, bnds

    px = vert[:, 0]
    py = vert[:, 1]

    # Polygon edges
    x1 = node[edge[:, 0], 0]
    y1 = node[edge[:, 0], 1]
    x2 = node[edge[:, 1], 0]
    y2 = node[edge[:, 1], 1]

    # Bounding box of polygon
    xmin = min(x1.min(), x2.min())
    xmax = max(x1.max(), x2.max())
    ymin = min(y1.min(), y2.min())
    ymax = max(y1.max(), y2.max())

    # Quick reject for points outside global bbox
    in_bbox = (
        (px >= xmin - ftol)
        & (px <= xmax + ftol)
        & (py >= ymin - ftol)
        & (py <= ymax + ftol)
    )
    if not in_bbox.any():
        return inside, bnds

    idx_pts = np.nonzero(in_bbox)[0]
    px_c = px[idx_pts]
    py_c = py[idx_pts]

    # Precompute edge vertical ranges
    eymin = np.minimum(y1, y2)
    eymax = np.maximum(y1, y2)

    # For each candidate point, accumulate crossings
    for j, (xq, yq) in enumerate(zip(px_c, py_c)):
        crossings = 0
        on_boundary = False

        for k in range(edge.shape[0]):
            ylow = eymin[k]
            yhigh = eymax[k]

            # Quick reject by vertical range
            if yq < ylow - ftol or yq > yhigh + ftol:
                continue

            x1k = x1[k]
            y1k = y1[k]
            x2k = x2[k]
            y2k = y2[k]

            # Check if point lies on the segment within tolerance
            vx = x2k - x1k
            vy = y2k - y1k
            wx = xq - x1k
            wy = yq - y1k
            seg_len2 = vx * vx + vy * vy
            if seg_len2 > 0.0:
                # Perpendicular distance squared from point to line
                cross = vx * wy - vy * wx
                dist2 = (cross * cross) / seg_len2
                if dist2 <= ftol * ftol:
                    # Also check projection lies within segment extents
                    dot = vx * wx + vy * wy
                    if -ftol <= dot <= seg_len2 + ftol:
                        on_boundary = True
                        break

            # Ray-casting: consider upward crossings of horizontal ray
            # to the right of (xq, yq).
            # Ignore horizontal edges (y1 == y2).
            if abs(y2k - y1k) <= ftol:
                continue

            # Check if edge straddles the ray vertically.
            if (y1k > yq) != (y2k > yq):
                x_int = x1k + (yq - y1k) * (x2k - x1k) / (y2k - y1k)
                if x_int > xq:
                    crossings += 1

        if on_boundary:
            bnds[idx_pts[j]] = True
            inside[idx_pts[j]] = True
        else:
            inside[idx_pts[j]] = crossings % 2 == 1

    return inside, bnds


# ---------------------------------------------------------------------------
# Shapely fast path
# ---------------------------------------------------------------------------


def _inpoly_shapely(
    vert: np.ndarray,
    node: np.ndarray,
    edge: np.ndarray,
    ftol: float,
) -> Tuple[np.ndarray, np.ndarray]:  # pragma: no cover - requires shapely
    if not _HAVE_SHAPELY:
        return _inpoly_raycasting(vert, node, edge, ftol)

    # Attempt to honour edge connectivity by decomposing into rings.
    # If this fails (malformed or ambiguous edges), fall back to the
    # robust ray-casting implementation.
    try:
        rings = _edges_to_rings(node, edge)
    except ValueError:
        return _inpoly_raycasting(vert, node, edge, ftol)

    if not rings:
        return _inpoly_raycasting(vert, node, edge, ftol)

    outer = rings[0]
    holes = rings[1:] if len(rings) > 1 else None

    polygon = _shapely_geom.Polygon(outer, holes=holes)
    prepared = _shapely_prep.prep(polygon)

    pts_geom = [_shapely_geom.Point(x, y) for x, y in vert]

    inside = np.array([prepared.contains(p) for p in pts_geom], dtype=bool)
    # Boundary detection via distance to polygon boundary
    bnds = np.array(
        [polygon.boundary.distance(p) <= ftol for p in pts_geom], dtype=bool
    )
    return inside, bnds


# ---------------------------------------------------------------------------
# Matplotlib fast path
# ---------------------------------------------------------------------------


def _inpoly_matplotlib(
    vert: np.ndarray,
    node: np.ndarray,
    edge: np.ndarray,
    ftol: float,
) -> Tuple[np.ndarray, np.ndarray]:  # pragma: no cover - requires matplotlib
    if not _HAVE_MPL:
        return _inpoly_raycasting(vert, node, edge, ftol)

    try:
        rings = _edges_to_rings(node, edge)
    except ValueError:
        return _inpoly_raycasting(vert, node, edge, ftol)

    # Construct a Path with one or more subpaths (outer + holes).
    vertices_list = []
    codes_list = []
    for coords in rings:
        if len(coords) == 0:
            continue
        vertices_list.append(coords[0])
        codes_list.append(_MplPath.MOVETO)
        for p in coords[1:]:
            vertices_list.append(p)
            codes_list.append(_MplPath.LINETO)
        # Close ring explicitly
        vertices_list.append(coords[0])
        codes_list.append(_MplPath.CLOSEPOLY)

    if not vertices_list:
        return _inpoly_raycasting(vert, node, edge, ftol)

    vertices_arr = np.asarray(vertices_list, dtype=float)
    codes_arr = np.asarray(codes_list, dtype=int)
    path = _MplPath(vertices_arr, codes=codes_arr)

    inside = path.contains_points(vert, radius=0.0)

    # Approximate boundary detection: shrink/expand a bit using radius.
    on_or_inside = path.contains_points(vert, radius=ftol)
    just_inside = np.logical_and(on_or_inside, ~inside)
    bnds = just_inside
    return inside, bnds


def _edges_to_rings(node: np.ndarray, edge: np.ndarray) -> list[np.ndarray]:
    """Convert an edge list into one or more closed coordinate rings.

    The edges are assumed to encode disjoint simple cycles. The first
    ring is treated as the outer boundary; subsequent rings may be
    interpreted as holes by callers.

    Raises
    ------
    ValueError
        If the edge set cannot be decomposed into a collection of
        simple, closed cycles.
    """

    if edge.size == 0:
        return []

    # Build adjacency: each vertex has exactly two incident edges in a
    # collection of disjoint cycles. We enforce a modest sanity check
    # here; anything more complex falls back to ray-casting.
    from collections import defaultdict

    adj: dict[int, list[int]] = defaultdict(list)
    for u, v in edge:
        adj[int(u)].append(int(v))
        adj[int(v)].append(int(u))

    for v, nbrs in adj.items():
        if len(nbrs) != 2:
            raise ValueError("edge set does not represent simple cycles")

    visited: set[int] = set()
    rings: list[np.ndarray] = []

    for start in adj.keys():
        if start in visited:
            continue

        ring_idx = []
        current = start
        prev = None
        while True:
            ring_idx.append(current)
            visited.add(current)
            nbrs = adj[current]
            # Choose the neighbour that is not the previous vertex.
            if prev is None:
                nxt = nbrs[0]
            else:
                nxt = nbrs[0] if nbrs[1] == prev else nbrs[1]
            prev, current = current, nxt
            if current == start:
                break

        # Map indices to coordinates
        coords = node[np.asarray(ring_idx, dtype=int)]
        rings.append(coords)

    return rings
